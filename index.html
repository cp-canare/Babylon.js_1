<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head runat="server">
    <title></title>
</head>
<body>
    <form id="form1" runat="server">

        <!-- -------------------- START side_menu -------------------- -->
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <style>
            body
            {
                font-family: "Lato", sans-serif;
            }
            .menuNav
            {
                height: 100%;
                width: 32px;
                position: fixed;
                z-index: 1;
                top: 0;
                left: 0;
                background-color: #1c75bc;
                overflow-x: hidden;
                
                outline: none;
                cursor: pointer;
                text-align: left;
                border: none;
                font-size: 20px;
                padding: 16px 8px 6px 16px; /*TOP RIGHT BOTTOM LEFT*/
            }
            .sidenav
            {
                height: 100%;
                width: 0;
                position: fixed;
                z-index: 1;
                top: 0;
                left: 0;
                background-color: #1c75bc;
                overflow-x: hidden;
                transition: 0.5s;
                padding-top: 10px;
            }
            .sidenav a, .dropdown-btn, .placeholder-btn
            {
                padding: 6px 8px 6px 16px; /*TOP RIGHT BOTTOM LEFT*/
                text-decoration: none;
                font-size: 20px;
                display: block;
                transition: 0.3s;
                border: none;
                background: none;
                width: 100%;
                text-align: left;
                cursor: pointer;
                outline: none;
            }
            .sidenav a:hover
            {
            color: #f1f1f1;
            }
            .active
            {
                color: white;
            }
            .dropdown-container
            {
                display: none;
                background-color: #1cbcb3;
                padding-left: 8px;
            }
            .fa-caret-down
            {
                float: right;
                padding-right: 8px;
            }
            .sidenav .closebtn
            {
                position: absolute;
                top: 0;
                right: 25px;
                font-size: 30px;
                margin-left: 50px;
            }
            @media screen and (max-height: 450px)
            {
                .sidenav { padding-top: 15px; }
                .sidenav a { font-size: 18px; }
            }
        </style>
        <div id="sidenav" class="sidenav">
            <span href="javascript:void(0)" class="closebtn" onclick="closeNav()" style="text-align:right; cursor:pointer;"></span>
            <button type="button" class="placeholder-btn" onclick="closeNav()" >â˜°</button>
            <button type="button" class="dropdown-btn">ðŸ§° Links
                <i class="fa fa-caret-down">â–¼</i>
            </button>
            <div class="dropdown-container">
                <a href="test3D.aspx">
                    ðŸ”™ test3D.aspx
                </a>
                <a href="test3DViewToilet.aspx">
                    ðŸ”™ test3DViewToilet.aspx
                </a>
                <a href="test3DViewSinkv2.aspx">
                    ðŸ”™ test3DViewSinkv2.aspx
                </a>
                <a href="test3DViewCS4510Q.aspx">
                    ðŸ”™ test3DViewCS4510Q.aspx
                </a>
                <a href="test3DViewToiletScan.aspx">
                    ðŸ”™ test3DViewToiletScan.aspx
                </a>
                <a href="test3DPlayground.aspx">
                    ðŸ”™ test3DPlayground.aspx
                </a>
                <a href="test3DTest.aspx">
                    ðŸ”™ test3DTest.aspx
                </a>
            </div>
            <a></a> <!-- EXTRA SIDE BUTTONS GO HERE -->
        </div>
        <script>
            var dropdown = document.getElementsByClassName("dropdown-btn");
            var i;
            for (i = 0; i < dropdown.length; i++) {
                dropdown[i].addEventListener("click", function () {
                    this.classList.toggle("active");
                    var dropdownContent = this.nextElementSibling;
                    if (dropdownContent.style.display === "block") {
                        dropdownContent.style.display = "none";
                    } else {
                        dropdownContent.style.display = "block";
                    }
                });
            }
            function openNav() {
                document.getElementById("sidenav").style.width = "250px";
                document.getElementById("menuNav").style.width = "0";
                document.getElementById("menuNav").style.padding = "0px 0px 0px 0px"; /*TOP RIGHT BOTTOM LEFT*/
            }

            function closeNav() {
                document.getElementById("sidenav").style.width = "0";
                document.getElementById("menuNav").style.width = "30px";
                document.getElementById("menuNav").style.padding = "16px 8px 6px 16px"; /*TOP RIGHT BOTTOM LEFT*/
            }
        </script>
        <div id="menuNav" class="menuNav"><span onclick="openNav()">â˜°</span></div>
        <!-- -------------------- END side_menu -------------------- -->
        <div class="main" style="margin-left: 55px;"> <!-- class="main" margin should match width of .menuNav -->

            <style></style>
            <script></script>

            <!-- ------------------------------------------------------- START Babylon.js ------------------------------------------------------- -->
            
            <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
            <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
            <script src="https://preview.babylonjs.com/ammo.js"></script>
            <script src="https://preview.babylonjs.com/cannon.js"></script>
            <script src="https://preview.babylonjs.com/Oimo.js"></script>
            <script src="https://preview.babylonjs.com/earcut.min.js"></script>
            <script src="https://preview.babylonjs.com/babylon.js"></script>
            <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
            <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
            <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
            <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
            <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
            <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
            <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
    
            <style>
                .scene
                {
                    width: calc(100vw - 70px);
                    height: calc(100vh - 16px);
                    overflow: hidden;
                }
                #renderCanvas
                {
                    width: 100%;
                    height: 100%;
                    touch-action: none;
                }
            </style>

            <div class="scene">
                <canvas id="renderCanvas"></canvas>
            </div>
            
            <script>
                var canvas = document.getElementById("renderCanvas");

                var startRenderLoop = function (engine, canvas)
                {
                    engine.runRenderLoop(function ()
                    {
                        if (sceneToRender && sceneToRender.activeCamera)
                        {
                            sceneToRender.render();
                        }
                    });
                }

                var engine = null;
                var scene = null;
                var sceneToRender = null;
                var createDefaultEngine = function () { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, disableWebGL2Support: false }); };
                const createScene = () => {

                    // This creates a basic Babylon Scene object (non-mesh)
                    const scene = new BABYLON.Scene(engine);

                    //enable Physics
                    scene.enablePhysics();

                    // ArcRotateCamera, rotating camera
                    const camera = new BABYLON.ArcRotateCamera("camera", (Math.PI / 4) * 8, Math.PI / 2.5, 30, new BABYLON.Vector3(0, 0, 0));

                    // This attaches the camera to the canvas
                    camera.attachControl(canvas, true);

                    // This creates a light, aiming 1, 1, 0
                    const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));


                    // The first parameter can be used to specify which mesh to import. Here we import all meshes
                    //BABYLON.SceneLoader.ImportMesh("", "https://raw.githubusercontent.com/cp-canare/Babylon.js_1/master/", "editWall3d.stl", scene, function (newMeshes) {
                    BABYLON.SceneLoader.ImportMesh("", "https://raw.githubusercontent.com/cp-canare/Babylon.js_1/master/", "editFloor3D.stl", scene, function (newMeshes) {
                        // Set the target of the camera to the first imported mesh
                        camera.target = newMeshes[0];

                        let editWall3d = newMeshes[0];
        
                        editWall3d.physicsImpostor = new BABYLON.PhysicsImpostor(editWall3d, BABYLON.PhysicsImpostor.MeshImpostor, { mass: 0, friction: 0, restitution: 0.3 });

                        var ticker = 0;
                        let spheres = [];

                        newMeshes[0].isPickable = false;
                        newMeshes[0].scaling = new BABYLON.Vector3(0.1, 0.1, 0.1); //scaling to 1/10 size

                        BABYLON.SceneLoader.ImportMeshAsync("", "https://raw.githubusercontent.com/cp-canare/Babylon.js_1/master/", "editWalls3D.stl", scene).then((result => {
                            result.meshes[0].name = 'editWalls3D';
                            result.meshes[0].scaling = new BABYLON.Vector3(0.1, 0.1, 0.1); //scaling to 1/10 size
                            result.meshes[0].isPickable = false;
                        }));

                        //START DRAG
                        var ground = newMeshes[0];
                        var startingPoint;
                        var getGroundPosition = function () {
                            var pickinfo = scene.pick(scene.pointerX, scene.pointerY, function (mesh) { return mesh == ground; });
                            if (pickinfo.hit) {
                                return pickinfo.pickedPoint;
                            }
                            return null;
                        }
                        var pointerDown = function (mesh) {
                            currentMesh = mesh;
                            startingPoint = getGroundPosition();
                            if (startingPoint) { // we need to disconnect camera from canvas
                                setTimeout(function () {
                                    camera.detachControl(canvas);
                                }, 0);
                            }
                        }
                        var pointerUp = function () {
                            if (startingPoint) {
                                camera.attachControl(canvas, true);
                                startingPoint = null;
                                return;
                            }
                        }
                        var pointerMove = function () {
                            if (!startingPoint) {
                                return;
                            }
                            var current = getGroundPosition();
                            if (!current) {
                                return;
                            }
                            var diff = current.subtract(startingPoint);
                            currentMesh.position.addInPlace(diff);
                            startingPoint = current;
                        }
                        scene.onPointerObservable.add((pointerInfo) => {
                            switch (pointerInfo.type) {
                                case BABYLON.PointerEventTypes.POINTERDOWN:
                                    if (pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh != ground) {
                                        gizmoManager.rotationGizmoEnabled = true;
                                        pointerDown(pointerInfo.pickInfo.pickedMesh)
                                    }
                                    break;
                                case BABYLON.PointerEventTypes.POINTERUP:
                                    pointerUp();
                                    break;
                                case BABYLON.PointerEventTypes.POINTERMOVE:
                                    pointerMove();
                                    break;
                            }
                        });
                        //END DRAG

                        //init gizmoManager
                        const gizmoManager = new BABYLON.GizmoManager(scene)

                        //rotationGizmo, rotate y axis
                        gizmoManager.rotationGizmoEnabled = true;
                        gizmoManager.gizmos.rotationGizmo.xGizmo.isEnabled = false;
                        gizmoManager.gizmos.rotationGizmo.zGizmo.isEnabled = false;
                        gizmoManager.gizmos.rotationGizmo.snapDistance = Math.PI / 4;
                        gizmoManager.gizmos.rotationGizmo.attachedNode = null;
                        
                        //positionGizmo, move x (left & right) & z (forward & backward)
                        //gizmoManager.positionGizmoEnabled = true;
                        //gizmoManager.gizmos.positionGizmo.yGizmo.isEnabled = false
                        //gizmoManager.gizmos.positionGizmo.snapDistance = 1;

                        /*
                        //editCS4510Q.stl
                        //BABYLON.SceneLoader.ImportMeshAsync("", "https://raw.githubusercontent.com/cp-canare/Babylon.js_1/master/", "editCS4510Q.stl", scene)
                        BABYLON.SceneLoader.ImportMeshAsync("", "./glb/", "editCS4510Q.stl", scene)
                            .then((result => {
                                result.meshes[0].name = 'editCS4510Q';
                                result.meshes[0].position.y = 0;
                                result.meshes[0].position.x = -45;
                                result.meshes[0].position.z = -55;
                                result.meshes[0].physicsImpostor = new BABYLON.PhysicsImpostor(result.meshes[0], BABYLON.PhysicsImpostor.MeshImpostor, { mass: 0, friction: 0, restitution: 0.3 });

                                //result.meshes[0].scaling = new BABYLON.Vector3(2, 2, 2); //scaling to 2x size
                                result.meshes[0].scaling = new BABYLON.Vector3(0.5, 0.5, 0.5); //scaling to half size
                                
                            }));
                        */
                        /*
                        //editSinkv2.stl
                        //BABYLON.SceneLoader.ImportMeshAsync("", "https://raw.githubusercontent.com/cp-canare/Babylon.js_1/master/", "editSinkv2.stl", scene)
                        BABYLON.SceneLoader.ImportMeshAsync("", "./glb/", "editSinkv2.stl", scene)
                            .then((result => {
                                result.meshes[0].name = 'editSinkv2';
                                result.meshes[0].position.y = 50;
                                result.meshes[0].position.x = 55;
                                result.meshes[0].position.z = 65;
                                result.meshes[0].physicsImpostor = new BABYLON.PhysicsImpostor(result.meshes[0], BABYLON.PhysicsImpostor.MeshImpostor, { mass: 0, friction: 0, restitution: 0.3 });

                                //result.meshes[0].scaling = new BABYLON.Vector3(2, 2, 2); //scaling to 2x size
                                result.meshes[0].scaling = new BABYLON.Vector3(0.5, 0.5, 0.5); //scaling to half size
                                
                            }));
                        */
                        /*
                        //editToilet.stl
                        //BABYLON.SceneLoader.ImportMeshAsync("", "https://raw.githubusercontent.com/cp-canare/Babylon.js_1/master/", "editToilet.stl", scene)
                        BABYLON.SceneLoader.ImportMeshAsync("", "./glb/", "editToilet.stl", scene)
                            .then((result => {
                                result.meshes[0].name = 'editToilet';
                                result.meshes[0].position.y = 0;
                                result.meshes[0].position.x = -50;
                                result.meshes[0].position.z = 50;
                                result.meshes[0].rotation.y = (Math.PI / 4) * 2;
                                //result.meshes[0].rotation.y = 1.55; //rotation
                                result.meshes[0].physicsImpostor = new BABYLON.PhysicsImpostor(result.meshes[0], BABYLON.PhysicsImpostor.MeshImpostor, { mass: 0, friction: 0, restitution: 0.3 });

                                //result.meshes[0].scaling = new BABYLON.Vector3(2, 2, 2); //scaling to 2x size
                                result.meshes[0].scaling = new BABYLON.Vector3(0.5, 0.5, 0.5); //scaling to half size
                                
                            }));
                        */
                        /*
                        //editToiletScan.stl
                        //BABYLON.SceneLoader.ImportMeshAsync("", "https://raw.githubusercontent.com/cp-canare/Babylon.js_1/master/", "editToiletScan.stl", scene)
                        BABYLON.SceneLoader.ImportMeshAsync("", "./glb/", "editToiletScan.stl", scene)
                            .then((result => {
                                result.meshes[0].name = 'editToiletScan';
                                result.meshes[0].position.y = 0;
                                result.meshes[0].position.x = 55;
                                result.meshes[0].position.z = -50;
                                result.meshes[0].rotation.y = (Math.PI / 4) * 6;
                                //result.meshes[0].rotation.y = -1.55; //rotation
                                result.meshes[0].physicsImpostor = new BABYLON.PhysicsImpostor(result.meshes[0], BABYLON.PhysicsImpostor.MeshImpostor, { mass: 0, friction: 0, restitution: 0.3 });

                                //result.meshes[0].scaling = new BABYLON.Vector3(2, 2, 2); //scaling to 2x size
                                result.meshes[0].scaling = new BABYLON.Vector3(0.5, 0.5, 0.5); //scaling to half size
                                
                            }));
                        */

                        // Our built-in 'sphere' shape. Params: name, subdivs, size, scene
                        // var sphre = BABYLON.Mesh.CreateSphere("", 16, 1, scene);
                        // sphre.position.y = 10;

                        /*
                        //create random spheres to test collision
                        scene.registerBeforeRender(function () {
                            if (ticker++ % 60) return;

                            let s = BABYLON.MeshBuilder.CreateSphere("s", { diameter: 20 });
                            s.position.y = 30;
                            s.position.z = 0 + Math.random();
                            s.position.x = 0 + Math.random();

                            s.physicsImpostor = new BABYLON.PhysicsImpostor(s, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 1 });
                            spheres.push(s);

                            spheres.forEach(function (sphere)
                            {
                                if (sphere.position.y < -50)
                                {
                                    sphere.dispose();
                                }
                            });
    
                            spheres = spheres.filter(s => !s.isDisposed());
                        });
                        */
                    });

                    //START DROPDOWN
                    var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                    var dropdownA = new Dropdown(advancedTexture, "40px", "180px");
                    dropdownA.button.children[0].text = "Select Model";
                    dropdownA.top = "10px"
                    dropdownA.left = "0px";
                    dropdownA.addOption(0, "CS4510Q.stl");
                    dropdownA.addOption(1, "Sinkv2.stl");
                    dropdownA.addOption(2, "Toilet.stl");
                    dropdownA.addOption(3, "ToiletScan.stl");

                    // Child 0 / "Option A"
                    dropdownA.options.children[0].onPointerClickObservable.add(function () {
                        if (scene.getMeshByName(`editCS4510Q`) != null) {
                            scene.getMeshByName(`editCS4510Q`).dispose();
                        }
                        else {
                            BABYLON.SceneLoader.ImportMeshAsync("", "https://raw.githubusercontent.com/cp-canare/Babylon.js_1/master/", "editCS4510Q.stl", scene).then((result => {
                                result.meshes[0].name = 'editCS4510Q';
                                result.meshes[0].scaling = new BABYLON.Vector3(0.1, 0.1, 0.1); //scaling to 1/10 size
                                //result.meshes[0].addBehavior(drag);
                                //result.meshes[0].scaling = new BABYLON.Vector3(0.5, 0.5, 0.5); //scaling to half size
                            }));
                        }
                    });
                    dropdownA.options.children[1].onPointerClickObservable.add(function () {
                        if (scene.getMeshByName(`editSinkv2`) != null) {
                            scene.getMeshByName(`editSinkv2`).dispose();
                        }
                        else {
                            BABYLON.SceneLoader.ImportMeshAsync("", "https://raw.githubusercontent.com/cp-canare/Babylon.js_1/master/", "editSinkv2.stl", scene).then((result => {
                                result.meshes[0].name = 'editSinkv2';
                                result.meshes[0].position.y = 4;
                                result.meshes[0].scaling = new BABYLON.Vector3(0.1, 0.1, 0.1); //scaling to 1/10 size
                                //result.meshes[0].addBehavior(drag);
                            }));
                        }
                    });
                    dropdownA.options.children[2].onPointerClickObservable.add(function () {
                        if (scene.getMeshByName(`editToilet`) != null) {
                            scene.getMeshByName(`editToilet`).dispose();
                        }
                        else {
                            BABYLON.SceneLoader.ImportMeshAsync("", "https://raw.githubusercontent.com/cp-canare/Babylon.js_1/master/", "editToilet.stl", scene).then((result => {
                                result.meshes[0].name = 'editToilet';
                                result.meshes[0].scaling = new BABYLON.Vector3(0.1, 0.1, 0.1); //scaling to 1/10 size
                                //result.meshes[0].addBehavior(drag);
                            }));
                        }
                    });
                    dropdownA.options.children[3].onPointerClickObservable.add(function () {
                        if (scene.getMeshByName(`editToiletScan`) != null) {
                            scene.getMeshByName(`editToiletScan`).dispose();
                        }
                        else {
                            BABYLON.SceneLoader.ImportMeshAsync("", "https://raw.githubusercontent.com/cp-canare/Babylon.js_1/master/", "editToiletScan.stl", scene).then((result => {
                                result.meshes[0].name = 'editToiletScan';
                                result.meshes[0].scaling = new BABYLON.Vector3(0.1, 0.1, 0.1); //scaling to 1/10 size
                                //result.meshes[0].addBehavior(drag);
                            }));
                        }
                    });
                    // END  DROPDOWN

                    //var drag = new BABYLON.PointerDragBehavior({ dragPlaneNormal: new BABYLON.Vector3(0, 1, 0) });
                    //drag.validateDrag = (targetPosition) => {
                    //    if (targetPosition.x > 6) { targetPosition.x = 6 }
                    //    if (targetPosition.x < -6) { targetPosition.x = -6 }
                    //    if (targetPosition.z > 6) { targetPosition.z = 6 }
                    //    if (targetPosition.z < -6) { targetPosition.z = -6 }
                    //    else { return true }
                    //}

                    /*
                    // Modify based on keypress
                    document.onkeydown = (e) => {
                        if (e.key == 'w' || e.key == 'a' || e.key == 's' || e.key == 'd') {
                            if (e.key == 'w') {
                                gizmoManager.positionGizmoEnabled = true;
                            }
                            if (e.key == 'a') {
                                gizmoManager.gizmos.positionGizmo.x += 10;
                            }
                            if (e.key == 's') {
                                gizmoManager.scaleGizmoEnabled = true;
                            }
                            if (e.key == 'd') {
                                gizmoManager.boundingBoxGizmoEnabled = true;
                            }
                        }
                    };
                    */

                    return scene;
                };

                //START DROPDOWN
                var Dropdown = (function () {
                    function Dropdown(advancedTexture, height, width, color, background) {
                        // Members
                        this.height = height;
                        this.width = width;
                        this.color = color || "black";
                        this.background = background || "white";

                        this.advancedTexture = advancedTexture;

                        // Container
                        this.container = new BABYLON.GUI.Container();
                        this.container.width = this.width;
                        this.container.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                        this.container.isHitTestVisible = false;

                        // Primary button
                        this.button = BABYLON.GUI.Button.CreateSimpleButton(null, "Please Select");
                        this.button.height = this.height;
                        this.button.background = this.background;
                        this.button.color = this.color;
                        this.button.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;

                        // Options panel
                        this.options = new BABYLON.GUI.StackPanel();
                        this.options.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                        this.options.top = this.height;
                        this.options.isVisible = false;
                        this.options.isVertical = true;

                        var _this = this;
                        this.button.onPointerUpObservable.add(function () {
                            _this.options.isVisible = !_this.options.isVisible;
                        });

                        // add controls
                        this.advancedTexture.addControl(this.container);
                        this.container.addControl(this.button);
                        this.container.addControl(this.options);

                        // Selection
                        this.selected = null;
                        this.selectedValue = null;
                    }
                    Object.defineProperty(Dropdown.prototype, 'top', {
                        get: function () {
                            return this.container.top;
                        },
                        set: function (value) {
                            this.container.top = value;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Dropdown.prototype, 'left', {
                        get: function () {
                            return this.container.left;
                        },
                        set: function (value) {
                            this.container.left = value;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Dropdown.prototype.addOption = function (value, text, color, background) {
                        var _this = this;
                        var button = BABYLON.GUI.Button.CreateSimpleButton(text, text);
                        button.height = _this.height;
                        button.paddingTop = "-1px";
                        button.background = background || _this.background;
                        button.color = color || _this.color;
                        button.onPointerUpObservable.add(function () {
                            _this.options.isVisible = false;
                            _this.button.children[0].text = text;
                            _this.selected = button;
                            _this.selectedValue = value;
                        });
                        this.options.addControl(button);
                    };
                    return Dropdown;
                }());
                // END  DROPDOWN

                window.initFunction = async function ()
                {
                    var asyncEngineCreation = async function ()
                    {
                        try
                        {
                            return createDefaultEngine();
                        }
                        catch (e)
                        {
                            console.log("the available createEngine function failed. Creating the default engine instead");
                            return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
                    if (!engine) throw 'engine should not be null.';
                    startRenderLoop(engine, canvas);
                    window.scene = createScene();
                };
                initFunction().then(() =>
                {
                    sceneToRender = scene
                });

                // Resize
                window.addEventListener("resize", function ()
                {
                    engine.resize();
                });
            </script>

            <!-- ------------------------------------------------------- END Babylon.js ------------------------------------------------------- -->

        </div>

    </form>
</body>
</html>
